#! /usr/bin/perl
# good luck charm
use strict;
use warnings;

# ==================================================
# main part
# ==================================================
if (!(defined($ARGV[0]))) {
    displayNormalHelp();
}

elsif ($ARGV[0] eq '-v' || $ARGV[0] eq '--version') {
    displayVersion();
}

elsif ($ARGV[0] eq 'node') {
    processForNode();
}

elsif ($ARGV[0] eq 'pods') {
    processForPods();
}

elsif ($ARGV[0] eq 'tcpdump') {
    processForTcpdump();
}

elsif ($ARGV[0] eq 'mongodb') {
    processForMongodb();
}

else {
    displayNormalHelp();
}

# ==================================================
# S/W Version part
# ==================================================
# --------------------------------------------------
sub displayVersion {
    my $version = "1.0";

    print "resourcectl Version " . $version . "\n";
}

# ==================================================
# Help part
# ==================================================
# --------------------------------------------------
sub displayNormalHelp {

    print "Commands to manipulate kubernetes resources\n";
    print "\n";
    print "Usage:\n";
    print "  resourcectl [OPTIONS] | [Commands]\n";
    print "\n";
    print "Commands:\n";
    print "  node                Operate node resources\n";
    print "  pods                Operate the main container of the Pod\n";
    print "  tcpdump             Operate the pod side container\n";
    # print "  mongodb             Operate mongodb\n";
    print "\n";
    print "Options:\n";
    print "  -h, --help          help for resourcectl\n";
    print "  -v, --version       Show version\n"
}

# --------------------------------------------------
sub displayNodeHelp {
    print "Commands to manipulate kubernetes resources\n";
    print "\n";
    print "Usage:\n";
    print "  resourcectl [Commands] | [Node Num] | [Options] \n";
    print "\n";
    print "Commands:\n";
    print "  list                Show nodes that can be operated\n";
    print "\n";
    print "Options:\n";
    print "  -h, --help          help for resourcectl\n";
}

# --------------------------------------------------
sub displayPodHelp {
    print "Commands to manipulate kubernetes resources\n";
    print "\n";
    print "Usage:\n";
    print "  resourcectl [Commands] | [Pod Num] | [Options] \n";
    print "\n";
    print "Commands:\n";
    print "  list                Show nodes that can be operated\n";
    print "  deploy              Deploy NFs in sequence\n";
    print "  clear               Delete NFs in sequence\n";
    print "\n";
    print "Options:\n";
    print "  -h, --help          help for resourcectl\n";
}

# --------------------------------------------------
sub displayTcpdumpHelp {
    print "Commands to manipulate kubernetes resources\n";
    print "\n";
    print "Usage:\n";
    print "  resourcectl [Commands] | [Pod Num] | [Options] \n";
    print "\n";
    print "Commands:\n";
    print "  list                Show nodes that can be operated\n";
    print "  dump                Start capture\n";
    print "  stop                Stop capture\n";
    print "  get                 Get the capture log\n";
    print "\n";
    print "Options:\n";
    print "  -h, --help          help for resourcectl\n";
}

# --------------------------------------------------
sub displayMongodbHelp {
    print "Commands to manipulate kubernetes resources\n";
    print "\n";
    print "Usage:\n";
    print "  resourcectl [Commands] | [Options] \n";
    print "\n";
    print "Commands:\n";
    print "  register            Outputs the register status of NF\n";
    print "\n";
    print "Options:\n";
    print "  -h, --help          help for resourcectl\n";
}

# ==================================================
# Get Network Function part
# ==================================================
# --------------------------------------------------
sub getNetworkFunctionList {
    my $namespaces = $ENV{namespaces};

    unless (defined $namespaces) {
        print "Load the rc file and define the environment variable namespaces.\n";
        exit(0);
    }

    if ($namespaces eq "f5gc") {
        return ("mongodb", "nrf", "udr", "udm", "ausf", "nssf", "amf", "pcf", "upf", "smf", "webui", "gnb", "ue");
    }

    elsif ($namespaces eq "open5gs") {
        return ("pcrf", "pgw", "sgw", "mme", "enb", "ue");
    }

    else {
        print "Unexpected namespaces have been defined in the environment variables.\n";
        exit(0);
    }
}

# ==================================================
# Node part
# ==================================================
# --------------------------------------------------
sub processForNode {
    my @hostnames = getHostList();

    if (!(defined($ARGV[1]))) {
        displayNodeHelp();
    }

    elsif ($ARGV[1] eq 'list') {
        &displayHostList(@hostnames);
    }

    elsif ($ARGV[1] =~ /[0-9]/ && $ARGV[1] < $#hostnames+1 ) {
        &executeSshCommand(@hostnames);
    }

    else {
        displayNodeHelp();
    }
}

# --------------------------------------------------
sub getHostList {
    my @hostnames = ();

    open (my $filehandle, '<', '/etc/hosts') or die 'Cannot open file: $!';
    while (my $buff = <$filehandle>) {
        chomp($buff);
        if ($buff =~ /^127.[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}/) {
            next;
        }
        if ($buff =~ / master| node/) {
            $buff =~ s/^[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3} //;
            push(@hostnames, $buff);
        }
    }
    close ($filehandle);

    return @hostnames;
}

# --------------------------------------------------
sub displayHostList {
    my @hostnames = @_;

    print "\n";
    print "==================== \n";
    print "Host list \n";
    print "==================== \n";
    print "\n";

    for (my $i = 0; $i <= $#hostnames; $i++) {
        print $i . " " . $hostnames[$i] . "\n";
    }
    print "\n";
}

# --------------------------------------------------
sub executeSshCommand {
    my $username = $ENV{USER};
    my @hostnames = @_;

    my $sshcommand = "ssh " . $username . "@" . $hostnames[$ARGV[1]];
    # print $sshcommand . "\n";
    system($sshcommand);
}

# ==================================================
# Pod part
# ==================================================
# --------------------------------------------------
sub processForPods {
    my @nf = ();
    my @nfuuid = ();
    getNetworkFunctionListInformation(\@nf, \@nfuuid);

    if (!(defined($ARGV[1]))) {
        displayPodHelp();
    }

     elsif ($ARGV[1] eq 'list') {
        &displayPodList(@nf);
    }

    elsif ($ARGV[1] =~ /[0-9]/ && $ARGV[1] < $#nfuuid+1) {
        executeKubectlCommandTargetNumber(@nfuuid);
    }

    elsif (grep {$_ =~ $ARGV[1]} @nfuuid) {
        executeKubectlCommandTargetFunctionName(@nf, @nfuuid);
    }

    elsif ($ARGV[1] eq 'clear') {
        clearForPods();
    }


    elsif ($ARGV[1] eq 'deploy') {
        deployForPods();
    }

    else {
        displayPodHelp();
    }
}

# --------------------------------------------------
sub getNetworkFunctionListInformation {
    my $namespaces = $ENV{namespaces};
    my @nfs = getNetworkFunctionList();
    my $nf = $_[0];
    my $nfuuid = $_[1];

    open (my $filehandle, "kubectl get pods -n $namespaces -o wide |") or die 'Cannot open file: $!';
    while (my $buff = <$filehandle>) {
        chomp($buff);
        foreach my $list (@nfs) {
            if ($buff =~ $list) {
                push(@$nf, $list);
                $buff =~ s/\s+[0-9]\/[0-9].*//;
                push(@$nfuuid, $buff);
            }
        }
    }
    close ($filehandle);
}

# --------------------------------------------------
sub displayPodList {
    my @nf = @_;

    print "\n";
    print "==================== \n";
    print "Pod list \n";
    print "==================== \n";
    print "\n";

    for (my $i = 0; $i <= $#nf; $i++) {
        print $i . " " . $nf[$i] . "\n";
    }
    print "\n";
}

# --------------------------------------------------
sub executeKubectlCommandTargetNumber {
    my $namespaces = $ENV{namespaces};
    my @nfuuid = @_;

    my $kubecommand = "kubectl exec -n " . $namespaces . " -it " . $nfuuid[$ARGV[1]] . " -- /bin/sh";
    system($kubecommand);

}

# --------------------------------------------------
sub executeKubectlCommandTargetFunctionName {
    my $namespaces = $ENV{namespaces};
    my @nf = $_[0];
    my @nfuuid = $_[1];

    while (my ($i, $j) = each @nf) {
        if ($j =~ $ARGV[1]) {
            my $kubecommand = "kubectl exec -n " . $namespaces . " -it " . $nfuuid[$i] . " -- /bin/sh";
            system($kubecommand);
            last;
        }
    }
}

# --------------------------------------------------
sub clearForPods {
    my $namespaces = $ENV{namespaces};

    if (!(defined($ARGV[1]))) {
        displayPodHelp();
    }

    elsif ($namespaces eq "f5gc") {
        clearForFree5gcPod();
    }

    elsif ($namespaces eq "open5gs") {
        clearForOpen5gsPod();
    }

    else {
        displayPodHelp();
    }
}

# --------------------------------------------------
sub clearForFree5gcPod {
    my @targetManifestFiles = ($ENV{mongodb} ,$ENV{nrf} ,$ENV{udr} ,$ENV{udm} ,$ENV{ausf} ,$ENV{nssf} ,$ENV{amf} ,$ENV{pcf} ,$ENV{upf} ,$ENV{smf} ,$ENV{webui} ,$ENV{gnb} ,$ENV{ue});
    my $flag = "";

    foreach my $targetManifestFile (@targetManifestFiles) {
        $flag = getNetworkFunctionStatus($targetManifestFile);

        if ($flag eq 1) {
            my $kubecommand = `kubectl delete -k $targetManifestFile`;
        }
    }
}

# --------------------------------------------------
sub clearForOpen5gsPod {
    print "\n";
}

# --------------------------------------------------
sub deployForPods {
    my $namespaces = $ENV{namespaces};

    if (!(defined($ARGV[1]))) {
        displayPodHelp();
    }

    elsif ($namespaces eq "f5gc") {
        deployForFree5gcPod();
    }

    elsif ($namespaces eq "open5gs") {
        deployForOpen5gsPod();
    }

    else {
        displayPodHelp();
    }
}

# --------------------------------------------------
sub deployForFree5gcPod {
    my @targetManifestFiles = ($ENV{mongodb} ,$ENV{nrf} ,$ENV{udr} ,$ENV{udm} ,$ENV{ausf} ,$ENV{nssf} ,$ENV{amf} ,$ENV{pcf} ,$ENV{upf} ,$ENV{smf} ,$ENV{webui} ,$ENV{gnb} ,$ENV{ue});
    my $flag = "";

    # NFs should be run in priority as below
    # NRF > UDR > UDM > AUSF > NSSF > AMF > PCF > UPF > SMF > N3IWF > WEBUI > GNB > UE
    foreach my $targetManifestFile (@targetManifestFiles) {
        my $kubecommand = `kubectl apply -k $targetManifestFile`;

        do {
            $flag = getNetworkFunctionStatus($targetManifestFile);
        } while ($flag eq 0);
    }
}

# --------------------------------------------------
sub deployForOpen5gsPod {
    print "\n";
}

# --------------------------------------------------
sub getNetworkFunctionStatus {
    my $namespaces = $ENV{namespaces};
    my @nfs = getNetworkFunctionList();
    my $targetManifestFile = $_[0];

    my $kubecommand = `kubectl get pods -n $namespaces`;
    my @lines = split (/[\n\r]/, $kubecommand);

    foreach my $nf (@nfs) {

        if ($targetManifestFile !~ $nf) {
            next;
        }

        foreach my $line (@lines) {

            if ($line !~ $nf) {
                next;
            }

            elsif ($line =~ $nf && $line =~ /Running/) {
                return 1;
            }
        }
    }
    return 0;
}

# ==================================================
# tcpdump part
# ==================================================
sub processForTcpdump {
    my @nf = ();
    my @nfuuid = ();
    getNetworkFunctionListInformation(\@nf, \@nfuuid);

    if (!(defined($ARGV[1]))) {
        displayTcpdumpHelp();
    }

     elsif ($ARGV[1] eq 'list') {
        displayPodList(@nf);
    }

     elsif ($ARGV[1] eq 'dump') {
        executeTcpdumpStart(@nfuuid);
    }

    elsif ($ARGV[1] eq 'stop') {
        executeTcpdumpStop(@nfuuid);
    }

    elsif ($ARGV[1] eq 'get') {
        executeTcpdumpGet(@nfuuid);
    }

    elsif ($ARGV[1] =~ /[0-9]/  && $ARGV[1] < $#nfuuid+1) {
        executeForTcpdumpKubectlCommandTargetNumber(@nfuuid);
    }

    elsif (grep {$_ =~ $ARGV[1]} @nfuuid) {
        executeForTcpdumpKubectlCommandTargetFunctionName(@nf, @nfuuid);
    }

    else {
        displayTcpdumpHelp();
    }
}

# --------------------------------------------------
sub executeForTcpdumpKubectlCommandTargetNumber {
    my $namespaces = $ENV{namespaces};
    my @nfuuid = @_;

    my $kubecommand = "kubectl exec -n " . $namespaces . " -it " . $nfuuid[$ARGV[1]] . " -c tcpdump -- /bin/bash";
    system($kubecommand);

}

# --------------------------------------------------
sub executeForTcpdumpKubectlCommandTargetFunctionName {
    my $namespaces = $ENV{namespaces};
    my @nf = $_[0];
    my @nfuuid = $_[1];

    while (my ($i, $j) = each @nf) {
        if ($j =~ $ARGV[1]) {
            my $kubecommand = "kubectl exec -n " . $namespaces . " -it " . $nfuuid[$i] . " -c tcpdump -- /bin/bash";
            system($kubecommand);
            last;
        }
    }
}

# --------------------------------------------------
sub executeTcpdumpStart {
    my $namespaces = $ENV{namespaces};
    my @nfuuids = @_;

    foreach my $nfuuid (@nfuuids) {
        my $kubecommand = "kubectl exec -n " . $namespaces . " -i " . $nfuuid . " -c tcpdump -- bash /tmp/tcpdump.sh start";
        system($kubecommand);
    }
}

# --------------------------------------------------
sub executeTcpdumpStop {
    my $namespaces = $ENV{namespaces};
    my @nfuuids = @_;

    foreach my $nfuuid (@nfuuids) {
        my $kubecommand = "kubectl exec -n " . $namespaces . " -i " . $nfuuid . " -c tcpdump -- bash /tmp/tcpdump.sh stop";
        system($kubecommand);
    }
}

# --------------------------------------------------
sub executeTcpdumpGet {
    my $namespaces = $ENV{namespaces};
    my @nfuuids = @_;

    foreach my $nfuuid (@nfuuids) {

        if ($nfuuid =~ /mongodb/) {
            next;
        }
 
        my $kubecommand = `kubectl exec -n $namespaces -i $nfuuid -c tcpdump -- ls /tmp/ | grep pcap`;
        my @lines = split (/[\n\r]/, $kubecommand);

        foreach my $line (@lines) {
            my $kubecommand = `kubectl cp -n $namespaces -c tcpdump $nfuuid:/tmp/$line /tmp/$line`;
        }
    }

    print "The pcap file has been retrieved under /tmp.\n";
}

# ==================================================
# mongodb part
# ==================================================
# --------------------------------------------------
sub processForMongodb {

    if (!(defined($ARGV[1]))) {
        displayMongodbHelp();
    }
    elsif ($ARGV[1] =~ "register") {
        executeForMongodbNetworkFunctionRegister();
    }
    else {
        displayMongodbHelp();
    }
}

# --------------------------------------------------
sub getMongodbInformation {
    my $namespaces = $ENV{namespaces};
    my $nf = "mongodb";
    my $nfuuid = $_[0];

    open (my $filehandle, "kubectl get pods -n $namespaces -o wide |") or die 'Cannot open file: $!';
    while (my $buff = <$filehandle>) {
        chomp($buff);
        if ($buff =~ $nf) {
            $buff =~ s/\s+[0-9]\/[0-9].*//;
            if ($buff =~ "mongodb") {
                $$nfuuid = $buff;
            }
        }
    }
    close ($filehandle);
}

# --------------------------------------------------
sub executeForMongodbNetworkFunctionRegister {
    my $namespaces = $ENV{namespaces};
    my $nfuuid = "";

    getMongodbInformation(\$nfuuid);

    my $kubecommand = "kubectl exec -n " . $namespaces . " -i " . $nfuuid . " -- mongoexport --port 27017 --db free5gc --collection NfProfile --type csv --out /home/test.csv --fields nfInstanceId,nfType,nfStatus > /dev/null 2>&1";
    system($kubecommand);
    $kubecommand = "kubectl exec -n " . $namespaces . " -i " . $nfuuid . " -- cat /home/test.csv";
    print "\n";
    system($kubecommand);
    print "\n";
}
